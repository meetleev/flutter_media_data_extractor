// Autogenerated from Pigeon (v17.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.meetleev.media_data_extractor

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class MediaDataSourceType(val raw: Int) {
  /** The video was included in the app's asset files. */
  ASSET(0),
  /** The video was downloaded from the internet. */
  NETWORK(1),
  /** The video was loaded off of the local filesystem. */
  FILE(2);

  companion object {
    fun ofRaw(raw: Int): MediaDataSourceType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MediaDataSource (
  /** Type of source of video */
  val type: MediaDataSourceType,
  /** Url of the video */
  val url: String,
  /** Only set for [asset] videos. The package that the asset was loaded from. */
  val packageName: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MediaDataSource {
      val type = MediaDataSourceType.ofRaw(list[0] as Int)!!
      val url = list[1] as String
      val packageName = list[2] as String?
      return MediaDataSource(type, url, packageName)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      type.raw,
      url,
      packageName,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VideoTrackData (
  /** A key describing the frame rate of a video format in frames/sec. */
  val frameRate: Double? = null,
  /** A key describing the width of the content in a video format. */
  val width: Double? = null,
  /** A key describing the height of the content in a video format. */
  val height: Double? = null,
  /** encoder-only, desired bitrate in bits/second */
  val bitRate: Double? = null,
  /** the duration of the content (in milliseconds) */
  val duration: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): VideoTrackData {
      val frameRate = list[0] as Double?
      val width = list[1] as Double?
      val height = list[2] as Double?
      val bitRate = list[3] as Double?
      val duration = list[4].let { if (it is Int) it.toLong() else it as Long? }
      return VideoTrackData(frameRate, width, height, bitRate, duration)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      frameRate,
      width,
      height,
      bitRate,
      duration,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VideoMetaData (
  /** The artist of the media. */
  val artist: String? = null,
  /** The title of the media. */
  val title: String? = null,
  /** The album of the media. */
  val album: String? = null,
  /** The genre of the media. */
  val genre: String? = null,
  /** The language of the media. */
  val language: String? = null,
  /** The author of the media. */
  val author: String? = null,
  /** The date of the media. */
  val date: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): VideoMetaData {
      val artist = list[0] as String?
      val title = list[1] as String?
      val album = list[2] as String?
      val genre = list[3] as String?
      val language = list[4] as String?
      val author = list[5] as String?
      val date = list[6] as String?
      return VideoMetaData(artist, title, album, genre, language, author, date)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      artist,
      title,
      album,
      genre,
      language,
      author,
      date,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VideoData (
  val meta: VideoMetaData? = null,
  val tracks: List<VideoTrackData?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): VideoData {
      val meta: VideoMetaData? = (list[0] as List<Any?>?)?.let {
        VideoMetaData.fromList(it)
      }
      val tracks = list[1] as List<VideoTrackData?>
      return VideoData(meta, tracks)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      meta?.toList(),
      tracks,
    )
  }
}

@Suppress("UNCHECKED_CAST")
private object MediaDataExtractorApiCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MediaDataSource.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoData.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoMetaData.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoTrackData.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is MediaDataSource -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is VideoData -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is VideoMetaData -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is VideoTrackData -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface MediaDataExtractorApi {
  fun getVideoData(dataSource: MediaDataSource, callback: (Result<VideoData>) -> Unit)

  companion object {
    /** The codec used by MediaDataExtractorApi. */
    val codec: MessageCodec<Any?> by lazy {
      MediaDataExtractorApiCodec
    }
    /** Sets up an instance of `MediaDataExtractorApi` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: MediaDataExtractorApi?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.media_data_extractor.MediaDataExtractorApi.getVideoData", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val dataSourceArg = args[0] as MediaDataSource
            api.getVideoData(dataSourceArg) { result: Result<VideoData> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
